#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Parse broadcast files to get deployed addresses
function getDeployedAddresses() {
  const broadcastDir = path.join(__dirname, '../contracts/broadcast/Deploy.s.sol');
  const addresses = {};

  try {
    // Find the latest deployment
    const chainDirs = fs.readdirSync(broadcastDir).filter(dir => {
      const stat = fs.statSync(path.join(broadcastDir, dir));
      return stat.isDirectory();
    });

    for (const chainDir of chainDirs) {
      const runLatestPath = path.join(broadcastDir, chainDir, 'run-latest.json');
      
      if (fs.existsSync(runLatestPath)) {
        const deployment = JSON.parse(fs.readFileSync(runLatestPath, 'utf8'));
        
        // Extract contract addresses from transactions
        deployment.transactions.forEach(tx => {
          if (tx.contractName && tx.contractAddress) {
            addresses[tx.contractName] = {
              address: tx.contractAddress,
              chainId: parseInt(chainDir)
            };
          }
        });
      }
    }
  } catch (error) {
    console.log('No deployments found yet');
  }

  return addresses;
}

// Copy ABIs from forge output
function copyABIs() {
  const outDir = path.join(__dirname, '../contracts/out');
  const targetDir = path.join(__dirname, '../frontend/contracts');

  // Create target directory if it doesn't exist
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }

  const contracts = {};

  try {
    const contractDirs = fs.readdirSync(outDir).filter(dir => {
      return dir.endsWith('.sol') && fs.statSync(path.join(outDir, dir)).isDirectory();
    });

    contractDirs.forEach(contractDir => {
      const files = fs.readdirSync(path.join(outDir, contractDir));
      const jsonFile = files.find(f => f.endsWith('.json') && !f.includes('.t.sol'));
      
      if (jsonFile) {
        const contractName = jsonFile.replace('.json', '');
        const contractPath = path.join(outDir, contractDir, jsonFile);
        const contractData = JSON.parse(fs.readFileSync(contractPath, 'utf8'));
        
        contracts[contractName] = {
          abi: contractData.abi,
          bytecode: contractData.bytecode.object
        };
      }
    });
  } catch (error) {
    console.error('Error reading ABIs:', error);
  }

  return contracts;
}

// Main function
function main() {
  console.log('📦 Updating frontend with contract data...\n');

  // Get deployed addresses
  const addresses = getDeployedAddresses();
  console.log('📍 Deployed addresses:', addresses);

  // Copy ABIs
  const contracts = copyABIs();
  console.log('📄 Found contracts:', Object.keys(contracts));

  // Combine addresses and ABIs
  const contractsData = {};
  
  Object.keys(contracts).forEach(name => {
    contractsData[name] = {
      abi: contracts[name].abi,
      address: addresses[name]?.address || null,
      chainId: addresses[name]?.chainId || null
    };
  });

  // Write to frontend
  const outputPath = path.join(__dirname, '../frontend/contracts/deployedContracts.ts');
  const outputDir = path.dirname(outputPath);

  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const tsContent = `// This file is auto-generated by update-frontend.js
// Do not edit manually

export const deployedContracts = ${JSON.stringify(contractsData, null, 2)} as const;

export type ContractName = keyof typeof deployedContracts;
`;

  fs.writeFileSync(outputPath, tsContent);
  
  console.log('\n✅ Frontend updated successfully!');
  console.log(`   Output: ${outputPath}`);
}

main();